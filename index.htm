<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>食鬼大冒險</title>
    
    <!-- PWA 設定 -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="icon.png">

    <style>
        body {
            background-color: #111;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            font-family: 'Courier New', Courier, monospace;
            color: white;
            touch-action: none;
            padding-top: env(safe-area-inset-top); /* 避開瀏海 */
            user-select: none;
            -webkit-user-select: none;
        }

        h1 { margin: 10px 0 5px 0; font-size: 24px; text-shadow: 2px 2px #333; }
        
        .info-bar {
            display: flex;
            justify-content: space-between;
            width: 300px;
            font-size: 18px;
            margin-bottom: 10px;
            background: #222;
            padding: 5px;
            border-radius: 5px;
        }

        .grid {
            display: flex;
            flex-wrap: wrap;
            width: 300px;
            height: 300px;
            border: 4px solid #444;
            background-color: black;
            box-shadow: 0 0 10px rgba(0,0,255,0.2);
        }

        .cell { width: 20px; height: 20px; box-sizing: border-box; }
        .wall { background-color: #1919A6; border: 1px solid #000; }
        .pac-dot { background-color: black; position: relative; }
        .pac-dot::after {
            content: ''; position: absolute; width: 4px; height: 4px;
            background-color: white; border-radius: 50%;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
        }
        .power-pellet { background-color: black; position: relative; }
        .power-pellet::after {
            content: ''; position: absolute; width: 12px; height: 12px;
            background-color: #ffb8ae; border-radius: 50%;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            animation: blink 0.3s infinite alternate;
        }
        @keyframes blink { from { opacity: 1; } to { opacity: 0.5; } }

        .pac-man { background-color: #FFFF00; border-radius: 50%; position: relative; z-index: 10; }
        .pac-man::after {
            content: ''; position: absolute; top: 20%; right: 0; width: 50%; height: 40%;
            background-color: black; clip-path: polygon(100% 0, 0 50%, 100% 100%);
        }

        .ghost { background-color: red; border-radius: 50% 50% 0 0; position: relative; z-index: 9; transition: background-color 0.2s; }
        .ghost::before, .ghost::after {
            content: ''; position: absolute; background: white; width: 6px; height: 6px; border-radius: 50%; top: 5px;
        }
        .ghost::before { left: 4px; } .ghost::after { right: 4px; }
        .scared-ghost { background-color: #0000FF !important; }
        .scared-ghost::before, .scared-ghost::after { background: #FFCCCC; }

        #status { height: 20px; color: yellow; font-weight: bold; font-size: 14px; text-align: center; margin: 5px 0; }

        .controls {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 5px;
            padding-bottom: 20px;
        }
        .ctrl-btn {
            width: 70px; height: 65px; background-color: #333;
            border: 2px solid #555; border-radius: 15px;
            color: white; font-size: 30px; display: flex;
            align-items: center; justify-content: center; cursor: pointer;
            box-shadow: 0 4px 0 #111;
        }
        .ctrl-btn:active { background-color: #555; transform: translateY(4px); box-shadow: none; }
        
        .restart-btn {
            padding: 8px 20px; background: #d32f2f; color: white; border: none; border-radius: 5px; font-size: 16px; margin-top: 5px;
        }
    </style>
</head>
<body>

    <h1>食鬼大冒險</h1>
    <div class="info-bar">
        <span>關卡: <span id="level-display">1</span></span>
        <span>分數: <span id="score">0</span></span>
    </div>
    
    <div class="grid"></div>
    <div id="status">點擊按鈕開始</div>

    <div class="controls">
        <div></div>
        <div class="ctrl-btn" onclick="handleInput('ArrowUp')">⬆️</div>
        <div></div>
        <div class="ctrl-btn" onclick="handleInput('ArrowLeft')">⬅️</div>
        <div class="ctrl-btn" onclick="handleInput('ArrowDown')">⬇️</div>
        <div class="ctrl-btn" onclick="handleInput('ArrowRight')">➡️</div>
    </div>
    
    <button class="restart-btn" onclick="location.reload()">重新開始</button>

    <script>
        // 註冊 Service Worker (PWA 核心)
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then(() => console.log('Service Worker Registered'));
        }

        // --- 遊戲程式碼 (與之前相同，略作壓縮) ---
        const grid = document.querySelector('.grid');
        const scoreDisplay = document.getElementById('score');
        const levelDisplay = document.getElementById('level-display');
        const statusDisplay = document.getElementById('status');
        const width = 15;
        let squares = [], score = 0, pacmanCurrentIndex = 0, ghosts = [], currentLevel = 0, isGameOver = false;

        const level1 = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,0,0,0,0,0,1,0,0,0,0,0,3,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,1,1,2,1,1,0,1,1,0,1,1,0,0,0,0,0,0,2,0,0,0,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,3,0,0,0,0,0,1,0,0,0,0,0,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1];
        const level2 = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,0,0,1,0,0,2,0,0,1,0,0,3,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,3,0,0,1,0,0,1,0,0,1,0,0,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1];
        const level3 = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,0,0,0,0,0,1,0,0,0,0,0,3,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1,1,1,2,1,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,3,0,0,0,0,0,1,0,0,0,0,0,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1];
        const levels = [level1, level2, level3];

        function startGame() {
            createBoard(levels[currentLevel]);
            setupGhosts();
            levelDisplay.innerHTML = currentLevel + 1;
            statusDisplay.innerHTML = "點擊箭頭移動"; isGameOver = false;
        }

        function createBoard(layout) {
            grid.innerHTML = ''; squares = []; ghosts.forEach(g => clearInterval(g.timerId));
            for (let i = 0; i < layout.length; i++) {
                const square = document.createElement('div');
                grid.appendChild(square); squares.push(square);
                square.classList.add('cell');
                if (layout[i] === 1) square.classList.add('wall');
                else if (layout[i] === 0) square.classList.add('pac-dot');
                else if (layout[i] === 2) square.classList.add('lair');
                else if (layout[i] === 3) square.classList.add('power-pellet');
            }
            pacmanCurrentIndex = 160; if(squares[pacmanCurrentIndex].classList.contains('wall')) pacmanCurrentIndex = 157;
            squares[pacmanCurrentIndex].classList.add('pac-man');
        }

        function setupGhosts() {
            ghosts = [new Ghost('ghost',96,250), new Ghost('ghost',98,300), new Ghost('ghost',82,400)];
            ghosts.forEach(g => { squares[g.currentIndex].classList.add(g.className); squares[g.currentIndex].style.backgroundColor = getGhostColor(g.startIndex); moveGhost(g); });
        }

        function getGhostColor(i) { return i===96?'red':i===98?'pink':'orange'; }
        
        function handleInput(key) {
            if(isGameOver) return;
            squares[pacmanCurrentIndex].classList.remove('pac-man');
            squares[pacmanCurrentIndex].style.transform = 'rotate(0deg)';
            let next = pacmanCurrentIndex, rotate = '0deg';
            if(key==='ArrowLeft') { next-=1; rotate='180deg'; } else if(key==='ArrowRight') { next+=1; rotate='0deg'; }
            else if(key==='ArrowUp') { next-=width; rotate='270deg'; } else if(key==='ArrowDown') { next+=width; rotate='90deg'; }
            if (squares[next] && !squares[next].classList.contains('wall')) {
                if (!(Math.abs(next-pacmanCurrentIndex)===1 && Math.floor(next/width)!==Math.floor(pacmanCurrentIndex/width))) pacmanCurrentIndex = next;
            }
            squares[pacmanCurrentIndex].classList.add('pac-man');
            squares[pacmanCurrentIndex].style.transform = `rotate(${rotate})`;
            pacDotEaten(); powerPelletEaten(); checkForGameOver(); checkForWin();
        }
        document.addEventListener('keydown', e => handleInput(e.key));

        function pacDotEaten() { if(squares[pacmanCurrentIndex].classList.contains('pac-dot')){ score++; scoreDisplay.innerHTML=score; squares[pacmanCurrentIndex].classList.remove('pac-dot'); } }
        function powerPelletEaten() {
            if(squares[pacmanCurrentIndex].classList.contains('power-pellet')){
                score+=10; scoreDisplay.innerHTML=score; squares[pacmanCurrentIndex].classList.remove('power-pellet');
                ghosts.forEach(g => g.isScared=true); setTimeout(()=>ghosts.forEach(g=>g.isScared=false), 5000);
            }
        }
        class Ghost { constructor(c,s,sp){this.className=c;this.startIndex=s;this.speed=sp;this.currentIndex=s;this.isScared=false;this.timerId=NaN;}}
        function moveGhost(g) {
            const dirs = [-1,1,width,-width]; let dir = dirs[Math.floor(Math.random()*dirs.length)];
            g.timerId = setInterval(() => {
                if(isGameOver) return;
                const next = g.currentIndex+dir;
                if(squares[next] && !squares[next].classList.contains('wall') && !squares[next].classList.contains('ghost')){
                    squares[g.currentIndex].classList.remove(g.className,'scared-ghost'); squares[g.currentIndex].style.backgroundColor='';
                    g.currentIndex+=dir;
                    squares[g.currentIndex].classList.add(g.className);
                    if(g.isScared){ squares[g.currentIndex].classList.add('scared-ghost'); }
                    else { squares[g.currentIndex].style.backgroundColor=getGhostColor(g.startIndex); }
                } else dir = dirs[Math.floor(Math.random()*dirs.length)];
                checkForGameOver();
            }, g.speed);
        }
        function checkForGameOver() {
            if(squares[pacmanCurrentIndex].classList.contains('ghost')){
                const g = ghosts.find(gh => gh.currentIndex===pacmanCurrentIndex);
                if(g.isScared){
                    squares[pacmanCurrentIndex].classList.remove('ghost','scared-ghost'); squares[pacmanCurrentIndex].style.backgroundColor='';
                    g.currentIndex=g.startIndex; score+=100; scoreDisplay.innerHTML=score;
                    squares[g.currentIndex].classList.add('ghost'); squares[g.currentIndex].style.backgroundColor=getGhostColor(g.startIndex); g.isScared=false;
                    statusDisplay.innerHTML="吃掉鬼魂 +100!"; setTimeout(()=>statusDisplay.innerHTML="快跑!",1000);
                } else { isGameOver=true; ghosts.forEach(gh=>clearInterval(gh.timerId)); statusDisplay.innerHTML="遊戲結束!"; statusDisplay.style.color='red'; }
            }
        }
        function checkForWin() {
            if(document.querySelectorAll('.pac-dot').length===0 && document.querySelectorAll('.power-pellet').length===0){
                isGameOver=true; ghosts.forEach(gh=>clearInterval(gh.timerId)); statusDisplay.innerHTML="關卡完成!"; statusDisplay.style.color='green';
                setTimeout(()=>{ currentLevel++; if(currentLevel<levels.length) startGame(); else { statusDisplay.innerHTML="恭喜通關!"; statusDisplay.style.color='gold'; }}, 2000);
            }
        }
        startGame();
    </script>
</body>
</html>